DOCUMENTO T√âCNICO: IMPLEMENTA√á√ÉO 100% COMPLETA DO M√ìDULO GPS
Sistema GuiasMEI - Gera√ß√£o Autom√°tica de Guias de Previd√™ncia Social

1. EXECUTIVE SUMMARY

Este documento t√©cnico detalha a implementa√ß√£o completa e robusta do m√≥dulo de Gera√ß√£o de Guias de Previd√™ncia Social (GPS) para o sistema GuiasMEI. Com a expectativa de atender milh√µes de usu√°rios, o objetivo principal √© garantir que a gera√ß√£o de GPS seja 100% compat√≠vel com as regras do Sistema de Acr√©scimos Legais (SAL) de 2025 e demais regulamenta√ß√µes governamentais, incluindo c√°lculos precisos de al√≠quotas, mora e juros, al√©m de um layout de PDF id√™ntico ao oficial. A arquitetura ser√° escal√°vel, resiliente e segura, utilizando tecnologias modernas e padr√µes de desenvolvimento de alta performance.

2. ARQUITETURA ATUAL vs NECESS√ÅRIA

2.1 Arquitetura Existente (Validar e Melhorar)

O sistema h√≠brido atual possui a seguinte estrutura:

*   Node.js (Fastify): Respons√°vel pela orquestra√ß√£o das intera√ß√µes via WhatsApp e por expor APIs internas para o frontend.
*   Python (FastAPI): Utilizado para a execu√ß√£o de c√°lculos de INSS e a gera√ß√£o de documentos PDF.
*   Supabase (PostgreSQL): Atua como a camada de persist√™ncia de dados, gerenciando o banco de dados relacional.
*   Z-API/Twilio: Plataformas para o envio e recebimento de mensagens via WhatsApp, utilizando webhooks para notificar o backend.

Status Atual:

*   ‚úÖ Fluxo de comunica√ß√£o via WhatsApp funcional.
*   ‚úÖ API Python para c√°lculos b√°sicos de INSS.
*   ‚úÖ Gera√ß√£o inicial de PDFs utilizando a biblioteca reportlab.
*   ‚ö†Ô∏è Valida√ß√µes das regras do SAL incompletas.
*   ‚ùå Aus√™ncia de versionamento para tabelas de regras (ex: teto INSS, sal√°rio m√≠nimo).
*   ‚ùå N√£o h√° implementa√ß√£o de cache distribu√≠do.
*   ‚ùå Falta de uma fila de processamento ass√≠ncrono para tarefas pesadas.
*   ‚ùå Aus√™ncia de ferramentas de monitoramento e observabilidade.

2.2 Arquitetura Necess√°ria para Produ√ß√£o (Milh√µes de Usu√°rios)

Para suportar milh√µes de usu√°rios e garantir a robustez e escalabilidade necess√°rias, a arquitetura ser√° aprimorada conforme a descri√ß√£o textual abaixo:

A arquitetura de produ√ß√£o ser√° composta por uma camada de prote√ß√£o e otimiza√ß√£o de tr√°fego, utilizando CloudFlare para CDN, prote√ß√£o WAF (Web Application Firewall) e Rate Limiting. O tr√°fego ser√° ent√£o direcionado para um Load Balancer (como Kong ou NGINX) que distribuir√° as requisi√ß√µes para um cluster de inst√¢ncias do Node.js (Fastify), configurado com no m√≠nimo 3 inst√¢ncias para alta disponibilidade e escalabilidade horizontal.

As aplica√ß√µes Node.js se comunicar√£o com um cluster de inst√¢ncias do Python (FastAPI), tamb√©m com no m√≠nimo 3 inst√¢ncias, para lidar com os c√°lculos complexos e a gera√ß√£o de PDFs.

Para otimiza√ß√£o de performance, um servidor Redis ser√° utilizado para caching de dados frequentemente acessados (como tabelas SAL e valida√ß√µes) e para gerenciamento de sess√µes.

Tarefas de processamento intensivo, como a gera√ß√£o de PDFs e o envio de mensagens WhatsApp, ser√£o descarregadas para uma Bull Queue, garantindo que as respostas ao usu√°rio sejam r√°pidas e que o processamento seja ass√≠ncrono e resiliente.

O banco de dados PostgreSQL (Supabase) ser√° configurado com Read Replicas para distribuir a carga de leitura e melhorar a performance.

Para garantir a observabilidade do sistema, ser√£o implementadas solu√ß√µes de monitoramento com Prometheus para coleta de m√©tricas e Grafana para visualiza√ß√£o e alertas. Os logs estruturados ser√£o centralizados e analisados atrav√©s de um ELK Stack (Elasticsearch, Logstash, Kibana).

Os PDFs gerados ser√£o armazenados em um servi√ßo de armazenamento de objetos como S3 e distribu√≠dos via CDN para acesso r√°pido e eficiente.

3. FLUXO COMPLETO GPS 100%

3.1 Fluxo Atualmente Implementado

O fluxo atual de gera√ß√£o de GPS √© o seguinte:

1.  O usu√°rio inicia a intera√ß√£o enviando uma mensagem via WhatsApp.
2.  A plataforma Z-API/Twilio recebe a mensagem e envia um webhook para o servi√ßo Node.js.
3.  O servi√ßo Node.js processa a requisi√ß√£o, realiza valida√ß√µes b√°sicas e chama a API Python para os c√°lculos e gera√ß√£o do PDF.
4.  A API Python executa os c√°lculos de INSS e gera o documento PDF.
5.  O servi√ßo Node.js recebe o PDF gerado e o envia de volta ao usu√°rio via WhatsApp.
6.  Os dados da GPS gerada s√£o persistidos no Supabase.

3.2 Melhorias Cr√≠ticas Necess√°rias

Para atingir a conformidade de 100% e a escalabilidade desejada, as seguintes melhorias cr√≠ticas s√£o indispens√°veis:

3.2.1 Valida√ß√µes SAL 2025 Completas

Todas as valida√ß√µes abaixo devem ser implementadas na API Python, utilizando dados versionados do banco de dados:

A. Valida√ß√£o de Per√≠odo V√°lido
*   ‚úÖ A GPS pode ser gerada apenas para os √∫ltimos 12 meses a partir da data atual.
*   ‚úÖ N√£o ser√° permitido gerar GPS para per√≠odos futuros.
*   ‚úÖ Per√≠odos muito antigos (mais de 12 meses) ser√£o bloqueados, a menos que haja uma regra espec√≠fica de recupera√ß√£o de contribui√ß√µes.
*   L√≥gica: Verificar se (data_atual - data_compet√™ncia) √© menor ou igual a 12 meses.

B. Valida√ß√£o de Teto INSS Versionado
*   ‚úÖ O valor do Teto do INSS muda anualmente, geralmente em janeiro.
*   ‚úÖ Para 2025, o teto √© um valor espec√≠fico (ex: R$ 7.786,00).
*   ‚úÖ Ser√° implementada uma tabela versionada no banco de dados (sal_version_history) para armazenar os tetos e outras regras por per√≠odo de compet√™ncia.
*   ‚úÖ O sistema buscar√° o teto correto com base na data de compet√™ncia da GPS.

C. Valida√ß√£o de Al√≠quota Progressiva Correta
*   ‚úÖ As al√≠quotas devem ser aplicadas corretamente conforme o tipo de contribuinte e a faixa salarial, utilizando a tabela versionada do SAL.
    *   Contribuinte Individual Normal:
        *   7.65% para valores at√© R$ 1.412,00
        *   9% para valores de R$ 1.412,01 at√© R$ 2.347,00
        *   12% para valores de R$ 2.347,01 at√© R$ 3.532,50
        *   14% para valores de R$ 3.532,51 at√© o teto do INSS
    *   Contribuinte Individual Simplificado: 11% sobre o sal√°rio m√≠nimo (ou valor declarado, limitado ao teto).
    *   Dom√©stico: 8% sobre o sal√°rio de contribui√ß√£o.
    *   Rural: 11,5% sobre o valor da produ√ß√£o (com aproveitamento de cr√©ditos).
*   ‚úÖ A al√≠quota aplicada deve ser a CORRETA para a faixa salarial e tipo de contribuinte.

D. Valida√ß√£o de Valor M√≠nimo
*   ‚úÖ O valor m√≠nimo de contribui√ß√£o √© o Sal√°rio M√≠nimo vigente (ex: R$ 1.412,00 para 2025).
*   ‚úÖ Esta regra se aplica a todos os tipos de contribuinte, exceto o Contribuinte Individual Simplificado, que pode optar por contribuir sobre um valor inferior ao sal√°rio m√≠nimo, desde que respeite a al√≠quota de 11%.
*   ‚úÖ O sistema deve for√ßar o arredondamento do valor final da contribui√ß√£o para m√∫ltiplos de R$ 0,05.

E. Valida√ß√£o de Duplicidade
*   ‚úÖ Ser√° implementada uma UNIQUE constraint no banco de dados na tabela gps_history para os campos (cpf, periodo_mes, periodo_ano, tipo_contribuinte).
*   ‚úÖ Isso evitar√° a emiss√£o de duas GPS id√™nticas para o mesmo contribuinte no mesmo per√≠odo e tipo.
*   ‚úÖ Se uma GPS j√° existir, o sistema deve retornar o reference_number da guia anterior, informando ao usu√°rio que a guia j√° foi emitida.

F. Valida√ß√£o de CPF/CNPJ
*   ‚úÖ O CPF (11 d√≠gitos) ou CNPJ (14 d√≠gitos) deve ter o formato correto.
*   ‚úÖ Ser√£o validados os d√≠gitos verificadores para garantir a autenticidade do n√∫mero.
*   ‚úÖ N√£o ser√£o aceitos padr√µes inv√°lidos (ex: "111.111.111-11", "00.000.000/0000-00").

G. Valida√ß√£o de Tipo de Contribuinte
*   ‚úÖ Apenas os valores v√°lidos e ativos do SAL ser√£o aceitos para o tipo de contribuinte.
*   ‚úÖ Ser√° utilizada uma tabela sal_classes no banco de dados para gerenciar os c√≥digos GPS e seus tipos correspondentes.
*   ‚úÖ O sistema bloquear√° tipos de contribuinte descontinuados ou inv√°lidos.

3.2.2 C√°lculos Corretos com Mora e Juros

Os c√°lculos devem incluir:

*   ‚úÖ Contribui√ß√£o base: Calculada pela aplica√ß√£o da al√≠quota correta sobre o valor de contribui√ß√£o.
*   ‚úÖ Juros: Aplicados √† taxa de 1% ao m√™s (ou fra√ß√£o) sobre o valor devido, caso a GPS esteja vencida.
*   ‚úÖ Multa: Aplicada √† taxa de 20% sobre o valor devido para pagamentos em atraso. Em casos de comprova√ß√£o de ilicitude, a multa pode ser de 75%.
*   ‚úÖ Vencimento padr√£o: O 15¬∫ dia do m√™s subsequente ao m√™s de compet√™ncia. Se o dia 15 cair em feriado ou fim de semana, o vencimento √© prorrogado para o pr√≥ximo dia √∫til.
*   ‚úÖ Descontos: Se aplic√°vel, considerar descontos para pagamentos antecipados ou em programas de regulariza√ß√£o.

3.2.3 Gera√ß√£o de Linha Digit√°vel Correta

*   ‚úÖ A linha digit√°vel deve ser gerada estritamente de acordo com a norma ISO 7064 MOD 97-10, que define o algoritmo para o c√°lculo do d√≠gito verificador.
*   ‚úÖ O formato banc√°rio padr√£o para a linha digit√°vel deve ser seguido: AAAAMMCC VVVVVVVVVVVV XX, onde AAAAMM √© o ano e m√™s de compet√™ncia, CC √© o c√≥digo da GPS, VVVVVVVVVVVV √© o valor e XX s√£o os d√≠gitos verificadores.
*   ‚úÖ Ser√° implementada uma valida√ß√£o interna do c√≥digo de barras antes da impress√£o para garantir que a linha digit√°vel e o c√≥digo de barras correspondam e sejam lidos corretamente.

3.2.4 Gera√ß√£o de PDF 100% Conforme Layout SAL

O PDF gerado deve ser visualmente id√™ntico e conter todas as informa√ß√µes exigidas pela Receita Federal para uma GPS oficial:

*   ‚úÖ Logo INSS: Inser√ß√£o do logotipo oficial do INSS.
*   ‚úÖ Tipo de guia: Indica√ß√£o clara de "GUIA DE PREVID√äNCIA SOCIAL - GPS".
*   ‚úÖ Dados do contribuinte: CPF, Nome completo, RG, Endere√ßo completo.
*   ‚úÖ N√∫mero de inscri√ß√£o: PIS/PASEP/NIT, conforme aplic√°vel ao tipo de contribuinte.
*   ‚úÖ C√≥digo GPS: O c√≥digo espec√≠fico da GPS (ex: 1007 para CI, 1163 para CI Simplificado).
*   ‚úÖ Compet√™ncia: M√™s e ano de refer√™ncia da contribui√ß√£o (ex: MM/AAAA).
*   ‚úÖ Valor da contribui√ß√£o: O valor principal devido.
*   ‚úÖ Juros e multas: Campos separados para juros e multas, se houver.
*   ‚úÖ Valor total: A soma da contribui√ß√£o, juros e multas.
*   ‚úÖ Data de vencimento: A data limite para o pagamento.
*   ‚úÖ Banco de cr√©dito recomendado: Informa√ß√µes sobre onde a guia pode ser paga.
*   ‚úÖ Linha digit√°vel: Apresentada de forma clara e leg√≠vel, em fonte monoespa√ßada e tamanho adequado.
*   ‚úÖ C√≥digo de barras: Implementa√ß√£o de um c√≥digo de barras funcional que possa ser lido por leitores banc√°rios.
*   ‚úÖ Instru√ß√µes de pagamento: Breves instru√ß√µes sobre como efetuar o pagamento.
*   ‚úÖ Whatsapp do suporte: Contato para suporte ao usu√°rio.

3.2.5 Integra√ß√£o com Sistema SAL Real

Para garantir a m√°xima conformidade e evitar problemas futuros, ser√° implementada uma integra√ß√£o com o sistema SAL oficial (ou APIs governamentais equivalentes, se dispon√≠veis):

*   ‚úÖ Valida√ß√£o de emiss√£o: Consultar o sistema SAL para verificar se uma GPS para o mesmo per√≠odo e contribuinte j√° foi emitida oficialmente.
*   ‚úÖ Verifica√ß√£o de d√©bitos: Consultar d√©bitos anteriores do contribuinte junto ao INSS.
*   ‚úÖ Hist√≥rico de pagamentos: Acessar o hist√≥rico de pagamentos para auxiliar o usu√°rio e validar informa√ß√µes.
*   ‚úÖ Valida√ß√£o de inscri√ß√£o: Confirmar o status de inscri√ß√£o do contribuinte (Contribuinte Individual, MEI, Dom√©stico) no sistema governamental.

4. IMPLEMENTA√á√ÉO DETALHADA

4.1 Schema Banco de Dados (Supabase/PostgreSQL)

As seguintes tabelas ser√£o criadas e gerenciadas via migrations no Supabase:

Tabela: sal_version_history
`sql
CREATE TABLE sal_version_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  effective_date DATE NOT NULL,
  teto_inss DECIMAL(10,2) NOT NULL,
  salario_minimo DECIMAL(10,2) NOT NULL,
  tabela_aliquotas JSONB NOT NULL, -- Estrutura JSON completa das faixas e al√≠quotas
  tabela_codes JSONB NOT NULL,     -- Mapeamento de c√≥digos GPS e tipos de contribuinte
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_sal_effective_date ON sal_version_history (effective_date DESC);

-- RLS Policy: Apenas administradores podem gerenciar
ALTER TABLE sal_version_history ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for all users" ON sal_version_history FOR SELECT USING (TRUE);
`

Tabela: gps_history
`sql
CREATE TABLE gps_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, -- Assumindo integra√ß√£o com auth.users do Supabase
  cpf VARCHAR(11) NOT NULL,
  nome_contribuinte TEXT,
  rg_contribuinte TEXT,
  endereco_contribuinte TEXT,
  pis_pasep_nit VARCHAR(15),
  periodo_mes INT NOT NULL CHECK (periodo_mes >= 1 AND periodo_mes <= 12),
  periodo_ano INT NOT NULL CHECK (periodo_ano >= 1900),
  tipo_contribuinte VARCHAR(50) NOT NULL, -- Enum: ci_normal, ci_simplificado, domestico, rural, etc
  codigo_gps VARCHAR(10) NOT NULL,
  valor_base DECIMAL(10,2) NOT NULL,
  aliquota DECIMAL(5,2) NOT NULL,
  valor_contribuicao DECIMAL(10,2) NOT NULL,
  valor_juros DECIMAL(10,2) DEFAULT 0.00,
  valor_multa DECIMAL(10,2) DEFAULT 0.00,
  valor_total DECIMAL(10,2) NOT NULL,
  vencimento DATE NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'emitted', 'paid', 'cancelled', 'overdue')),
  reference_number VARCHAR(50) UNIQUE NOT NULL,
  linha_digitavel VARCHAR(60) NOT NULL,
  pdf_url TEXT,
  emitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  paid_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(cpf, periodo_mes, periodo_ano, tipo_contribuinte)
);

CREATE INDEX idx_gps_cpf_emitted_at ON gps_history (cpf, emitted_at DESC);
CREATE INDEX idx_gps_status ON gps_history (status);
CREATE INDEX idx_gps_vencimento ON gps_history (vencimento);
CREATE INDEX idx_gps_user_id ON gps_history (user_id);

-- RLS Policy: Usu√°rio s√≥ pode ver suas pr√≥prias GPSs
ALTER TABLE gps_history ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for users based on user_id" ON gps_history FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Enable insert for users" ON gps_history FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable update for users" ON gps_history FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Enable delete for users" ON gps_history FOR DELETE USING (auth.uid() = user_id);
`

Tabela: gps_validation_log
`sql
CREATE TABLE gps_validation_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  gps_id UUID REFERENCES gps_history(id) ON DELETE CASCADE,
  validation_type VARCHAR(50) NOT NULL, -- Ex: 'teto_check', 'periodo_check', 'duplicidade_check', 'cpf_check'
  passed BOOLEAN NOT NULL,
  error_message TEXT,
  checked_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_validation_gps_id ON gps_validation_log (gps_id);
CREATE INDEX idx_validation_checked_at ON gps_validation_log (checked_at);

-- RLS Policy: Apenas administradores podem ver logs, ou usu√°rios podem ver logs de suas GPSs
ALTER TABLE gps_validation_log ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for users on their GPS validations" ON gps_validation_log FOR SELECT USING (
  (SELECT user_id FROM gps_history WHERE id = gps_id) = auth.uid()
);
CREATE POLICY "Enable insert for users on their GPS validations" ON gps_validation_log FOR INSERT WITH CHECK (
  (SELECT user_id FROM gps_history WHERE id = gps_id) = auth.uid()
);
`

Tabela: processing_queue
`sql
CREATE TABLE processing_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  gps_id UUID REFERENCES gps_history(id),
  status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  retry_count INT DEFAULT 0,
  error_details JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  processed_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_queue_status ON processing_queue (status);
CREATE INDEX idx_queue_created_at ON processing_queue (created_at);
`

Tabela: sal_classes (Dados Mestre)
`sql
CREATE TABLE sal_classes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  codigo_gps VARCHAR(10) UNIQUE NOT NULL,
  descricao TEXT NOT NULL,
  tipo_contribuinte VARCHAR(50) NOT NULL, -- Ex: 'ci_normal', 'ci_simplificado', 'domestico', 'rural'
  aliquota_minima DECIMAL(5,2),
  aliquota_maxima DECIMAL(5,2),
  requer_nit BOOLEAN DEFAULT FALSE,
  ativo BOOLEAN DEFAULT TRUE,
  valid_from DATE NOT NULL,
  valid_to DATE, -- NULL se v√°lido indefinidamente
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_sal_classes_codigo_gps ON sal_classes (codigo_gps);
CREATE INDEX idx_sal_classes_tipo_contribuinte ON sal_classes (tipo_contribuinte);
CREATE INDEX idx_sal_classes_validity ON sal_classes (valid_from, valid_to);

-- RLS Policy: Apenas administradores podem gerenciar
ALTER TABLE sal_classes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for all users" ON sal_classes FOR SELECT USING (TRUE);
`

4.2 Python API - M√≥dulo INSS Completo

A API Python (FastAPI) ser√° estruturada com as seguintes classes e endpoints:

Classe: SALVersionManager
*   M√©todo: get_sal_version(data_competencia: date) -> dict: Retorna o conjunto de regras SAL (teto, sal√°rio m√≠nimo, al√≠quotas) v√°lido para a data_competencia especificada, buscando de sal_version_history ou do cache Redis.
*   M√©todo: get_teto_inss(ano: int) -> Decimal: Retorna o teto do INSS para um determinado ano.
*   M√©todo: get_salario_minimo(ano: int) -> Decimal: Retorna o sal√°rio m√≠nimo para um determinado ano.
*   M√©todo: get_aliquotas(tipo: str, data: date) -> list: Retorna as faixas e al√≠quotas aplic√°veis para um tipo_contribuinte e data_competencia.
*   M√©todo: validate_against_sal(tipo: str, valor: Decimal, data: date) -> (bool, str): Valida se um valor est√° dentro dos limites (m√≠nimo/m√°ximo) para um tipo_contribuinte e data_competencia.

Classe: INSSCalculator
*   M√©todo: calcular_contribuinte_individual_normal(valor: Decimal, data: date) -> dict: Calcula a contribui√ß√£o para CI Normal, aplicando a al√≠quota progressiva.
*   M√©todo: calcular_contribuinte_individual_simplificado(valor: Decimal, data: date) -> dict: Calcula a contribui√ß√£o para CI Simplificado (11%).
*   M√©todo: calcular_domestico(valor: Decimal, data: date) -> dict: Calcula a contribui√ß√£o para Dom√©stico (8%).
*   M√©todo: calcular_rural(valor: Decimal, data: date) -> dict: Calcula a contribui√ß√£o para Rural (11.5%).
*   M√©todo: aplicar_mora_juros(valor_devido: Decimal, data_vencimento: date, data_pagamento: date) -> dict: Calcula juros de 1% ao m√™s (ou fra√ß√£o) sobre o valor_devido com base nas datas de vencimento e pagamento.
*   M√©todo: calcular_multa(valor_devido: Decimal, data_vencimento: date, data_pagamento: date, tipo_multa: str = 'normal') -> Decimal: Calcula multa de 20% (normal) ou 75% (ilicitude) sobre o valor_devido se o pagamento for ap√≥s o vencimento.
*   Retorna: Um dicion√°rio contendo { valor_base, aliquota, valor_contribuicao, valor_juros, valor_multa, valor_total, vencimento }.

Classe: GPSValidator
*   M√©todo: validar_periodo(periodo_mes: int, periodo_ano: int) -> (bool, str): Verifica se o per√≠odo est√° dentro dos √∫ltimos 12 meses e n√£o √© futuro.
*   M√©todo: validar_cpf(cpf: str) -> bool: Valida formato e d√≠gitos verificadores do CPF.
*   M√©todo: validar_valor(valor: Decimal, tipo: str, data: date) -> (bool, str): Valida se o valor est√° entre o sal√°rio m√≠nimo e o teto para o tipo e data espec√≠ficos.
*   M√©todo: validar_duplicidade(cpf: str, periodo_mes: int, periodo_ano: int, tipo: str) -> (bool, Optional[str]): Consulta gps_history para verificar duplicidade, retornando reference_number se existir.
*   M√©todo: validar_tipo_contribuinte(tipo: str) -> bool: Verifica se o tipo √© v√°lido e ativo em sal_classes.
*   Retorna: Um dicion√°rio { valido: bool, erros: list[str], avisos: list[str] }.

Classe: LDigitavelGenerator
*   M√©todo: gerar_linha_digitavel(reference_number: str, valor: Decimal, vencimento: date, codigo_gps: str) -> str: Gera a linha digit√°vel completa, incluindo o c√°lculo do d√≠gito verificador.
*   M√©todo: calcular_digito_verificador(base: str) -> str: Implementa o algoritmo ISO 7064 MOD 97-10.
*   M√©todo: validar_linha_digitavel(linha: str) -> bool: Valida a integridade de uma linha digit√°vel.
*   Retorna: A linha_digitavel formatada com o d√≠gito verificador.

Classe: PDFGenerator (melhorado)
*   M√©todo: gerar_pdf_completo(gps_data: dict) -> bytes: Gera o PDF completo da GPS.
*   Conte√∫do OBRIGAT√ìRIO:
    *   Logo INSS (carregado de um arquivo est√°tico ou S3).
    *   Cabe√ßalho "GUIA DE PREVID√äNCIA SOCIAL - GPS".
    *   Tipo de guia (ex: "Contribuinte Individual").
    *   Compet√™ncia (MM/AAAA).
    *   Dados do contribuinte (CPF, Nome, RG, Endere√ßo).
    *   PIS/PASEP/NIT (se aplic√°vel).
    *   C√≥digo GPS (ex: 1007).
    *   Valor da contribui√ß√£o, Juros, Multas, Valor Total.
    *   Data de vencimento.
    *   Banco de cr√©dito recomendado.
    *   Linha digit√°vel (fonte monoespa√ßada, tamanho grande).
    *   C√≥digo de barras (utilizando python-barcode ou similar).
    *   Instru√ß√µes de pagamento.
    *   Telefone WhatsApp de suporte.

Endpoint: POST /api/v1/guias/emitir
*   Entrada: { cpf, periodo_mes, periodo_ano, tipo_contribuinte, valor_base, nome, rg, endereco, pis_pasep, whatsapp }
*   Processo:
    1.  Validar entrada com Pydantic schema.
    2.  Chamar GPSValidator.validar_* para todas as valida√ß√µes (per√≠odo, CPF, valor, tipo).
    3.  Chamar GPSValidator.validar_duplicidade. Se duplicado, retornar 409 Conflict com reference_number anterior.
    4.  Obter regras SAL para a compet√™ncia via SALVersionManager.
    5.  Chamar INSSCalculator.calcular_* o m√©todo correto para o tipo de contribuinte.
    6.  Calcular mora e juros se a data de pagamento for posterior ao vencimento.
    7.  Gerar reference_number.
    8.  Chamar LDigitavelGenerator.gerar_linha_digitavel.
    9.  Chamar PDFGenerator.gerar_pdf_completo.
    10. Fazer upload do PDF para Supabase Storage (S3).
    11. Salvar registro completo em gps_history com status='emitted'.
    12. Registrar todas as valida√ß√µes e seus resultados em gps_validation_log.
    13. Enviar o PDF via WhatsApp (esta etapa ser√° ass√≠ncrona via Bull Queue).
    14. Retornar: { gps_id, reference_number, linha_digitavel, valor_total, vencimento, pdf_url } com status 202 Accepted (devido ao processamento ass√≠ncrono do PDF/WhatsApp).
*   Erros: Retornar 400 Bad Request para valida√ß√µes falhas, 409 Conflict para duplicidade, 500 Internal Server Error para falhas internas, com mensagens claras e c√≥digos de erro.

Endpoint: POST /api/v1/guias/complementacao
*   Entrada: { gps_id_anterior, valor_novo_aliquota }
*   Processo: Calcula a diferen√ßa entre a al√≠quota original (ex: 11%) e a al√≠quota desejada (ex: 20%) sobre o valor de contribui√ß√£o. Gera uma nova GPS de complementa√ß√£o com o valor da diferen√ßa.

Endpoint: GET /api/v1/guias/{gps_id}
*   Retorna: Dados completos de uma GPS emitida, incluindo status de pagamento e links para o PDF.

Endpoint: GET /api/v1/guias/periodo/{cpf}/{mes}/{ano}
*   Retorna: Uma lista de GPS emitidas para um determinado CPF em um per√≠odo espec√≠fico.

4.3 Node.js - Integra√ß√£o WhatsApp Melhorada

Os handlers e middlewares do Node.js (Fastify) ser√£o otimizados:

Handler: handleGenerateGps
*   Entrada: Recebe dados do webhook do WhatsApp ou de uma API interna, contendo { cpf, periodo_mes, periodo_ano, tipo_contribuinte, valor_base, user_id }.
*   Valida√ß√£o local: Realiza valida√ß√µes r√°pidas (formato CPF, per√≠odo b√°sico, valor entre SM e teto) antes de chamar a API Python para evitar carga desnecess√°ria.
*   Chamada √† Python API: Invoca o endpoint POST /api/v1/guias/emitir da API Python.
*   Tratamento de erro com retry: Implementa l√≥gica de retry (ex: 3 tentativas com backoff exponencial) para chamadas √† API Python em caso de falhas transit√≥rias.
*   Confirma√ß√£o WhatsApp: Envia uma mensagem de confirma√ß√£o imediata ao usu√°rio via WhatsApp, informando que a GPS est√° sendo processada e fornecendo o reference_number ou job_id da fila.
*   Log estruturado: Utiliza Winston para registrar todas as etapas do processo, incluindo entradas, sa√≠das, erros e tempos de resposta.

Middleware: ValidationMiddleware
*   Fun√ß√£o: Intercepta requisi√ß√µes de entrada para realizar valida√ß√µes r√°pidas e essenciais.
*   Valida√ß√µes:
    *   Formato do CPF/CNPJ.
    *   Per√≠odo de compet√™ncia (n√£o pode ser futuro, n√£o pode ser muito antigo).
    *   Valor de contribui√ß√£o (deve estar entre o sal√°rio m√≠nimo e o teto do INSS).
*   Retorno: Em caso de falha, retorna 400 Bad Request com uma mensagem de erro clara em portugu√™s.

Middleware: RateLimiting
*   Fun√ß√£o: Protege a API contra uso excessivo e ataques de nega√ß√£o de servi√ßo.
*   Limites:
    *   100 requisi√ß√µes por minuto por endere√ßo IP.
    *   1000 requisi√ß√µes por dia por usu√°rio autenticado.
*   Implementa√ß√£o: Utilizar um plugin de rate limiting para Fastify (ex: @fastify/rate-limit).

Middleware: ErrorHandler
*   Fun√ß√£o: Captura e processa erros que ocorrem na aplica√ß√£o.
*   Mapeamento: Mapeia erros espec√≠ficos da API Python (ex: DUPLICATE_GPS, VALIDATION_ERROR) para mensagens amig√°veis em portugu√™s e c√≥digos de status HTTP apropriados (ex: 409 Conflict, 400 Bad Request).
*   Log: Registra os erros de forma estruturada para an√°lise posterior.

4.4 Redis Cache - Implementa√ß√£o

O Redis ser√° utilizado para cache de dados e otimiza√ß√£o de performance:

*   Key: sal:version:{ano}
    *   Value: JSON completo contendo teto, sal√°rio m√≠nimo, faixas de al√≠quotas e c√≥digos GPS para um determinado ano.
    *   TTL: 86400 segundos (24 horas). Ser√° atualizado manualmente ou via webhook quando as regras do SAL mudarem.
*   Key: user:validation:{cpf}
    *   Value: JSON com { valid: bool, tipo_contribuinte: str, ativo: bool } para um CPF espec√≠fico, resultado de uma consulta ao sistema SAL real.
    *   TTL: 3600 segundos (1 hora).
*   Key: gps:duplicate:{cpf}:{periodo}:{tipo}
    *   Value: JSON com { exists: bool, reference_number: str } indicando se uma GPS j√° foi emitida para a combina√ß√£o de CPF, per√≠odo e tipo.
    *   TTL: 3600 segundos (1 hora).
*   Key: processing:queue:length
    *   Value: O n√∫mero atual de itens na fila de processamento.
    *   TTL: 60 segundos (1 minuto). Usado para monitoramento.

4.5 Bull Queue - Processamento Ass√≠ncrono

Uma fila Bull ser√° implementada para gerenciar tarefas de processamento ass√≠ncrono:

*   Queue: gps-generation
    *   Job: Cada job na fila representar√° uma solicita√ß√£o de gera√ß√£o de GPS, contendo { cpf, periodo_mes, periodo_ano, tipo_contribuinte, valor_base, user_id, whatsapp_number }.
    *   Processor: Um worker (Node.js ou Python) ser√° respons√°vel por processar os jobs. As etapas incluem:
        1.  Chamar a API Python para gerar o PDF.
        2.  Fazer upload do PDF para o S3.
        3.  Enviar o PDF finalizado ao usu√°rio via WhatsApp.
        4.  Atualizar o status da GPS em gps_history para 'emitted' ou 'failed'.
    *   Priority: Jobs podem ter prioridade (ex: 5 para normal, 1 para urgente).
    *   Attempts: Cada job ter√° 3 tentativas de execu√ß√£o em caso de falha.
    *   Backoff: Um mecanismo de backoff exponencial (ex: 2000ms, 4000ms, 8000ms) ser√° aplicado entre as tentativas.
    *   Timeout: Um timeout de 30000ms (30 segundos) ser√° configurado para cada job.
    *   OnFailed: Em caso de falha persistente, o erro ser√° registrado em gps_validation_log ou processing_queue.error_details, e um alerta ser√° enviado aos administradores. O usu√°rio ser√° notificado via WhatsApp sobre a falha.
    *   OnCompleted: Ap√≥s a conclus√£o bem-sucedida, o sucesso ser√° logado, e o usu√°rio ser√° notificado via WhatsApp com o PDF.

5. CHECKLIST DE IMPLEMENTA√á√ÉO

Fase 1: Banco de Dados (1-2 dias)

*   [ ] Criar migrations Supabase para sal_version_history, gps_history, gps_validation_log, processing_queue, sal_classes.
*   [ ] Criar todos os √≠ndices para performance conforme especificado.
*   [ ] Criar RLS policies para garantir que usu√°rios vejam apenas suas pr√≥prias GPSs e que administradores gerenciem tabelas de regras.
*   [ ] Implementar backup autom√°tico do Supabase.
*   [ ] Testar as constraints UNIQUE para evitar duplicidade de GPS.

Fase 2: Python API - Funda√ß√µes (3-5 dias)

*   [ ] Implementar a classe SALVersionManager com todos os m√©todos.
*   [ ] Implementar a classe INSSCalculator com todos os m√©todos de c√°lculo e aplica√ß√£o de mora/juros/multa.
*   [ ] Implementar a classe GPSValidator com todas as valida√ß√µes (per√≠odo, CPF, valor, duplicidade, tipo).
*   [ ] Popular a tabela sal_classes com dados de 2025.
*   [ ] Desenvolver testes unit√°rios (pytest) para todos os m√©todos de c√°lculo e valida√ß√£o, cobrindo cen√°rios reais e limites.

Fase 3: Python API - Gera√ß√£o (2-3 dias)

*   [ ] Implementar a classe LDigitavelGenerator com o algoritmo ISO 7064 MOD 97-10.
*   [ ] Implementar a classe PDFGenerator para gerar PDFs completos com logo INSS, todos os campos obrigat√≥rios, linha digit√°vel e c√≥digo de barras (usando python-barcode).
*   [ ] Adicionar o arquivo do logo INSS ao projeto.
*   [ ] Testar visualmente os PDFs gerados para garantir conformidade com o layout oficial.

Fase 4: Python API - Endpoints (2-3 dias)

*   [ ] Criar o endpoint POST /api/v1/guias/emitir com toda a l√≥gica de valida√ß√£o, c√°lculo, gera√ß√£o e persist√™ncia.
*   [ ] Criar o endpoint POST /api/v1/guias/complementacao.
*   [ ] Criar o endpoint GET /api/v1/guias/{gps_id}.
*   [ ] Criar o endpoint GET /api/v1/guias/periodo/{cpf}/{mes}/{ano}.
*   [ ] Testar todos os endpoints exaustivamente com ferramentas como Postman ou Insomnia.
*   [ ] Documentar a API com Swagger/OpenAPI.

Fase 5: Node.js Integra√ß√£o (2-3 dias)

*   [ ] Refatorar o handler handleGenerateGps para incluir valida√ß√µes locais, chamadas √† API Python e tratamento de erros.
*   [ ] Implementar o ValidationMiddleware para valida√ß√µes r√°pidas.
*   [ ] Implementar o RateLimiting para proteger a API.
*   [ ] Implementar o ErrorHandler para mapear erros e fornecer feedback amig√°vel.
*   [ ] Testar o fluxo completo via WhatsApp, desde a entrada do usu√°rio at√© a resposta.

Fase 6: Redis + Bull Queue (2-3 dias)

*   [ ] Configurar o Redis (Docker local ou servi√ßo em nuvem).
*   [ ] Integrar o SALVersionManager com o Redis para cache de tabelas SAL.
*   [ ] Criar a fila gps-generation com Bull Queue.
*   [ ] Implementar o job processor que consome da fila e executa a gera√ß√£o de PDF, upload e envio de WhatsApp.
*   [ ] Testar a fila com m√∫ltiplos jobs, verificando prioridade, retries e tratamento de falhas.

Fase 7: Monitoramento (2-3 dias)

*   [ ] Implementar Winston para logs estruturados em Node.js e Python.
*   [ ] Configurar Prometheus para coletar m√©tricas de CPU, mem√≥ria, lat√™ncia de API, taxa de erros, e tamanho da fila Bull.
*   [ ] Configurar Grafana com dashboards para visualiza√ß√£o das m√©tricas.
*   [ ] Configurar alertas no Grafana para eventos cr√≠ticos (ex: CPU > 80%, taxa de erro > 1%, fila Bull muito longa).
*   [ ] Implementar health checks (/health, /readiness, /liveness) para Node.js e Python.

Fase 8: Testes (3-5 dias)

*   [ ] Testes unit√°rios: Garantir cobertura de c√≥digo para todas as classes e fun√ß√µes cr√≠ticas (pytest para Python, Jest para Node.js).
*   [ ] Testes de integra√ß√£o: Validar a comunica√ß√£o entre Node.js e Python, e entre Python e Supabase/Redis.
*   [ ] Testes de carga: Utilizar ferramentas como k6 ou Artillery para simular 10.000 requisi√ß√µes simult√¢neas e 100 GPS geradas por segundo. Validar tempo de resposta (< 5s) e taxa de erro (< 0.1%).
*   [ ] Testes de seguran√ßa: Realizar varreduras para SQL injection, XSS, e outras vulnerabilidades comuns.
*   [ ] Testes E2E (End-to-End): Utilizar Selenium ou Cypress para simular o fluxo completo do usu√°rio via WhatsApp, desde a solicita√ß√£o at√© o recebimento do PDF e a valida√ß√£o no BD.

Fase 9: Deploy Produ√ß√£o (2-3 dias)

*   [ ] Preparar todas as vari√°veis de ambiente para produ√ß√£o.
*   [ ] Utilizar um secrets manager para credenciais sens√≠veis.
*   [ ] Configurar CI/CD (GitHub Actions, GitLab CI) para automa√ß√£o de builds e deploys.
*   [ ] Implementar estrat√©gia de blue-green deployment para deploys sem downtime.
*   [ ] Definir e testar a estrat√©gia de rollback em caso de falhas no deploy.

6. INSTRU√á√ïES PARA IA - IMPLEMENTA√á√ÉO C√ìDIGO

6.1 Para Ajustar Python API

Sua IA deve:

1.  Analisar os arquivos python/inss_calculator.py, python/gps_generator.py, e python/main.py (endpoints FastAPI).
2.  Refatorar a classe INSSCalculator para utilizar SALVersionManager e implementar todos os m√©todos de c√°lculo de contribui√ß√£o, mora e juros conforme a se√ß√£o 4.2.
3.  Adicionar todas as valida√ß√µes descritas na se√ß√£o 4.2 (per√≠odo, teto, al√≠quota, m√≠nimo, duplicidade, CPF/CNPJ, tipo de contribuinte) dentro da classe GPSValidator e integr√°-las aos endpoints.
4.  Gerar o PDF conforme o layout SAL 2025, incluindo logo INSS, todos os dados do contribuinte, valores detalhados, linha digit√°vel e c√≥digo de barras.
5.  Implementar a classe LDigitavelGenerator com o algoritmo ISO 7064 MOD 97-10.
6.  Criar testes unit√°rios abrangentes com pytest para todas as novas funcionalidades.
7.  Adicionar docstrings em portugu√™s para todas as classes e m√©todos.

Comandos para IA:
`
"Analise o arquivo python/inss_calculator.py e refatore a classe INSSCalculator 
para implementar todas as valida√ß√µes SAL 2025 descritas na se√ß√£o 4.2 deste documento. 
Inclua os m√©todos: calcular_contribuinte_individual_normal, 
calcular_contribuinte_individual_simplificado, calcular_domestico, calcular_rural, 
aplicar_mora_juros, e calcular_multa. Retorne c√≥digo completo e pronto para produ√ß√£o."

"Analise o arquivo python/gps_generator.py e refatore a classe PDFGenerator 
para gerar PDFs 100% conformes ao layout SAL 2025, incluindo logo INSS, 
todos os dados do contribuinte, valores detalhados, linha digit√°vel e c√≥digo de barras. 
Utilize a biblioteca python-barcode para o c√≥digo de barras. Retorne o c√≥digo completo."

"Analise o arquivo python/main.py e ajuste o endpoint POST /api/v1/guias/emitir 
para integrar as classes SALVersionManager, INSSCalculator, GPSValidator, 
LDigitavelGenerator e PDFGenerator. Implemente o fluxo completo de valida√ß√£o, 
c√°lculo, gera√ß√£o de PDF, upload para S3 e persist√™ncia em gps_history. 
Garanta que o retorno seja 202 Accepted e inclua o job_id da fila Bull."
`

6.2 Para Ajustar Node.js

Sua IA deve:

1.  Analisar o arquivo apps/server/src/routes/gps.ts.
2.  Refatorar o handler handleGenerateGps para incluir valida√ß√µes locais, chamadas √† API Python com retry logic e backoff exponencial, e logs estruturados com Winston.
3.  Implementar um ValidationMiddleware para valida√ß√µes r√°pidas de entrada.
4.  Implementar um RateLimiting para prote√ß√£o da API.
5.  Implementar um ErrorHandler para mapear erros da API Python para mensagens amig√°veis.
6.  Adicionar a l√≥gica para enfileirar o job na Bull Queue e enviar confirma√ß√£o imediata ao usu√°rio via WhatsApp.
7.  Adicionar coment√°rios e tipos TypeScript completos.

Comandos para IA:
`
"Refatore o handler handleGenerateGps em apps/server/src/routes/gps.ts 
para implementar as seguintes melhorias descritas na se√ß√£o 4.3:
1. Valida√ß√£o local antes de chamar Python.
2. Retry logic com 3 tentativas e backoff exponencial para chamadas √† API Python.
3. Logs estruturados com Winston.
4. Tratamento de erros espec√≠ficos da Python API, mapeando para mensagens amig√°veis.
5. Enviar confirma√ß√£o WhatsApp com reference_number ou job_id da fila.
6. Adicionar o job √† fila Bull para processamento ass√≠ncrono.
Retorne c√≥digo TypeScript com tipos completos."

"Crie um ValidationMiddleware para Fastify em apps/server/src/middlewares/validation.ts 
que valide o formato do CPF, se o per√≠odo est√° dentro dos √∫ltimos 12 meses e se o valor 
est√° entre o sal√°rio m√≠nimo e o teto do INSS. Retorne 400 Bad Request em caso de falha."

"Crie um ErrorHandler para Fastify em apps/server/src/middlewares/error.ts 
que capture erros da API Python (ex: DUPLICATE_GPS, VALIDATION_ERROR) e os mapeie 
para mensagens amig√°veis em portugu√™s e c√≥digos de status HTTP apropriados."
`

6.3 Para Criar SQL Migrations

Sua IA deve:

1.  Criar um arquivo supabase/migrations/[timestamp]_create_gps_tables.sql.
2.  Implementar todas as tabelas detalhadas na se√ß√£o 4.1 (sal_version_history, gps_history, gps_validation_log, processing_queue, sal_classes).
3.  Incluir todos os √≠ndices para performance.
4.  Criar as RLS policies para cada tabela conforme especificado.
5.  Adicionar triggers para updated_at autom√°tico em todas as tabelas.

Comandos para IA:
`
"Crie uma migration Supabase (arquivo .sql) que implemente todas as tabelas 
descritas na se√ß√£o 4.1 deste documento: sal_version_history, gps_history, 
gps_validation_log, processing_queue, sal_classes. Inclua √≠ndices, constraints 
UNIQUE, RLS policies para usu√°rios verem apenas suas pr√≥prias GPSs, 
e triggers para atualizar updated_at automaticamente."
`

7. ROTEIROS DE TESTE

7.1 Teste Unit√°rio - C√°lculo INSS

Caso 1: CI Normal com valor em faixa 1 (7.65%)
*   Entrada: valor_base=1200.00, tipo_contribuinte='ci_normal', data_competencia=2025-01-15
*   Esperado: aliquota=0.0765, valor_contribuicao=91.80
*   Assert: resultado['aliquota'] == 0.0765 e resultado['valor_contribuicao'] == 91.80

Caso 2: CI Normal com valor em faixa 4 (14%)
*   Entrada: valor_base=5000.00, tipo_contribuinte='ci_normal', data_competencia=2025-01-15
*   Esperado: aliquota=0.14, valor_contribuicao=700.00
*   Assert: resultado['aliquota'] == 0.14 e resultado['valor_contribuicao'] == 700.00

Caso 3: Valida√ß√£o Teto INSS
*   Entrada: valor_base=8000.00, tipo_contribuinte='ci_normal', data_competencia=2025-01-15
*   Esperado: Erro de valida√ß√£o indicando "Valor excede teto INSS".
*   Assert: resultado['valido'] == False e resultado['erros'][0] cont√©m "Excede teto".

Caso 4: Valida√ß√£o Per√≠odo Futuro
*   Entrada: periodo_mes=1, periodo_ano=2026 (assumindo data atual 2025)
*   Esperado: Erro de valida√ß√£o indicando "GPS n√£o pode ser gerada para per√≠odos futuros".
*   Assert: resultado['valido'] == False e resultado['erros'][0] cont√©m "per√≠odos futuros".

Caso 5: Mora e Juros (1 m√™s de atraso)
*   Entrada: valor_devido=1000.00, data_vencimento=2025-01-15, data_pagamento=2025-02-15
*   Esperado: valor_juros=10.00 (1% de 1000), valor_multa=200.00 (20% de 1000)
*   Assert: resultado['valor_juros'] == 10.00 e resultado['valor_multa'] == 200.00

7.2 Teste Integra√ß√£o - Fluxo Completo

1.  Pr√©-condi√ß√£o: Usu√°rio autenticado e com n√∫mero de WhatsApp configurado.
2.  A√ß√£o: Usu√°rio envia mensagem WhatsApp: "Quero gerar uma GPS para CI Normal, valor 1500, compet√™ncia 01/2025".
3.  Valida√ß√£o 1: O sistema Node.js recebe a mensagem, valida localmente e enfileira um job na Bull Queue. Responde ao usu√°rio com "Sua GPS est√° sendo processada. ID do pedido: [job_id]".
4.  Valida√ß√£o 2: O worker da Bull Queue processa o job:
    *   Chama a API Python com os dados.
    *   A API Python realiza todas as valida√ß√µes SAL, calcula a contribui√ß√£o, mora e juros (se aplic√°vel), gera a linha digit√°vel e o PDF.
    *   O PDF √© enviado para o Supabase Storage (S3).
    *   Um registro √© salvo na tabela gps_history com status='emitted' e todos os detalhes.
    *   Registros s√£o criados em gps_validation_log.
5.  Valida√ß√£o 3: O sistema envia o PDF da GPS para o WhatsApp do usu√°rio.
6.  Valida√ß√£o 4: Verificar no Supabase:
    *   A GPS est√° salva em gps_history com status='emitted'.
    *   O reference_number e linha_digitavel est√£o corretos.
    *   O pdf_url aponta para o PDF no S3.
    *   O PDF no S3 √© acess√≠vel e cont√©m todas as informa√ß√µes corretas e o layout oficial.
    *   Os logs em gps_validation_log mostram que todas as valida√ß√µes passaram.

7.3 Teste de Carga

*   Ferramenta: k6 ou Artillery.
*   Cen√°rio: Simular a gera√ß√£o de GPS para 10.000 usu√°rios simult√¢neos.
*   Taxa de requisi√ß√µes: 100 requisi√ß√µes de gera√ß√£o de GPS por segundo.
*   M√©tricas a validar:
    *   Tempo de resposta m√©dio: Deve ser inferior a 5 segundos para a resposta inicial do Node.js (enfileiramento).
    *   Taxa de erro: Deve ser inferior a 0.1% para todas as APIs.
    *   Utiliza√ß√£o de recursos: CPU e mem√≥ria dos clusters Node.js e Python, Redis e PostgreSQL devem permanecer dentro dos limites aceit√°veis (ex: CPU < 80%).
    *   Tamanho da fila Bull: O n√∫mero de jobs pendentes na fila deve ser gerenci√°vel e n√£o crescer indefinidamente.

8. CRONOGRAMA DE IMPLEMENTA√á√ÉO

Total Estimado: 5-6 semanas para produ√ß√£o.

*   Semana 1: Banco de Dados (Migrations, √çndices, RLS) + Python API - Funda√ß√µes (SALVersionManager, INSSCalculator, GPSValidator).
*   Semana 2: Python API - Gera√ß√£o (LDigitavelGenerator, PDFGenerator) + Python API - Endpoints (Implementa√ß√£o e testes iniciais).
*   Semana 3: Node.js Integra√ß√£o (Refatorar handlers, Middlewares de valida√ß√£o, rate limiting, error handling) + Redis Cache + Bull Queue (Setup e integra√ß√£o).
*   Semana 4: Monitoramento (Prometheus, Grafana, ELK Stack, Health Checks) + Testes (Unit√°rios, Integra√ß√£o, E2E iniciais).
*   Semana 5: Ajustes finos, otimiza√ß√µes de performance, Testes de Carga, Testes de Seguran√ßa.
*   Semana 6: Deploy em Produ√ß√£o, Homologa√ß√£o final, Documenta√ß√£o operacional.

9. ALERTAS E RISCOS

üö® CR√çTICO (Bloqueadores para produ√ß√£o):

*   Sem valida√ß√µes SAL completas: As GPS geradas ser√£o rejeitadas pelo governo, causando problemas legais e financeiros para os usu√°rios.
*   Sem cache Redis: O banco de dados (Supabase) ser√° sobrecarregado com picos de tr√°fego, resultando em lentid√£o e falhas.
*   Sem Bull Queue: O processamento s√≠ncrono de PDFs e envios de WhatsApp exceder√° o tempo limite de resposta do WhatsApp (>30s), resultando em falha na entrega.
*   Sem monitoramento e observabilidade: Ser√° imposs√≠vel identificar e depurar problemas em produ√ß√£o de forma eficiente, levando a longos per√≠odos de inatividade.
*   Linha digit√°vel incorreta: Guias n√£o poder√£o ser pagas, gerando insatisfa√ß√£o e problemas para o usu√°rio.

‚ö†Ô∏è IMPORTANTE (Impacto significativo na experi√™ncia do usu√°rio e conformidade):

*   Teto INSS muda anualmente: A falta de atualiza√ß√£o ou versionamento da tabela SAL resultar√° em c√°lculos incorretos a cada virada de ano.
*   PDF sem conte√∫do correto ou layout oficial: Pode levar √† rejei√ß√£o da guia por parte do INSS ou institui√ß√µes financeiras.
*   Rate limiting inadequado: A aplica√ß√£o estar√° vulner√°vel a ataques de nega√ß√£o de servi√ßo (DDoS) ou uso abusivo.
*   Falta de testes de carga: O sistema pode falhar inesperadamente sob alta demanda, mesmo com a arquitetura escal√°vel.
*   N√£o conformidade com LGPD: Risco de multas e perda de confian√ßa dos usu√°rios devido ao tratamento inadequado de dados pessoais.

10. PR√ìXIMOS PASSOS

1.  Revis√£o deste documento: Realizar uma revis√£o detalhada deste documento t√©cnico com toda a equipe de desenvolvimento e stakeholders.
2.  Cria√ß√£o de Issues: Transformar cada item do "CHECKLIST DE IMPLEMENTA√á√ÉO" em issues detalhadas no sistema de gerenciamento de projetos (ex: GitHub Issues, Jira).
3.  Designa√ß√£o de Desenvolvedores: Atribuir responsabilidades claras para os desenvolvedores de Node.js e Python para cada fase da implementa√ß√£o.
4.  Setup de Ambiente de Homologa√ß√£o: Configurar um ambiente de homologa√ß√£o (staging) que replique a arquitetura de produ√ß√£o para testes e valida√ß√µes.
5.  In√≠cio da Fase 1 (BD): Come√ßar imediatamente com a implementa√ß√£o das migrations e schemas de banco de dados.