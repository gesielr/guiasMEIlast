"""
Gerador de c√≥digo de barras GPS - VERS√ÉO CORRIGIDA FINAL
"""

class CodigoBarrasGPS:
    """Gerador correto de c√≥digo de barras GPS"""
    
    @staticmethod
    def calcular_dv_modulo11(codigo_sem_dv: str) -> str:
        """
        Calcula DV Geral (posi√ß√£o 4 do c√≥digo de barras)
        Calcula sobre 47 d√≠gitos (posi√ß√µes 1-3 + 5-48)

        [WARN] CORRE√á√ÉO CR√çTICA: Quando resto = 1, DV = 1 (n√£o zero!)
        """
        if len(codigo_sem_dv) != 47:
            raise ValueError(f"C√≥digo sem DV deve ter 47 d√≠gitos, tem {len(codigo_sem_dv)}")
        
        # Sequ√™ncia: 2,3,4,5,6,7,8,9,2,3,4...
        sequencia = [2, 3, 4, 5, 6, 7, 8, 9] * 6
        
        soma = 0
        for i, digito in enumerate(codigo_sem_dv):
            soma += int(digito) * sequencia[i]
        
        resto = soma % 11
        
        # [OK] CORRE√á√ÉO AQUI:
        if resto == 0:
            return "0"
        elif resto == 1:
            return "1"  # ‚Üê MUDAN√áA: antes retornava "0"
        else:
            return str(11 - resto)
    
    @staticmethod
    def calcular_dv_modulo10(campo: str) -> str:
        """
        DV M√≥dulo 10 para cada campo da linha digit√°vel
        Aplica da DIREITA para ESQUERDA (n√£o da esquerda!)

        Algoritmo correto:
        - Multiplica alternando 2 e 1, da DIREITA para ESQUERDA
        - Se produto >= 10, soma os d√≠gitos (ex: 14 ‚Üí 1+4=5)
        - DV = (10 - (soma % 10)) ou 0 se resto for 0
        """
        if len(campo) != 11:
            raise ValueError(f"Campo deve ter 11 d√≠gitos")

        soma = 0
        multiplicador = 2

        # Da DIREITA para ESQUERDA
        for i in range(len(campo) - 1, -1, -1):
            digito = int(campo[i])
            produto = digito * multiplicador

            # Se produto >= 10, soma os d√≠gitos
            if produto >= 10:
                produto = (produto // 10) + (produto % 10)

            soma += produto

            # Alterna entre 2 e 1
            multiplicador = 1 if multiplicador == 2 else 2

        resto = soma % 10

        if resto == 0:
            return "0"
        else:
            return str(10 - resto)
    
    @classmethod
    def gerar(cls, codigo_pagamento: str, competencia: str, 
              valor: float, nit: str) -> dict:
        """
        Gera c√≥digo de barras GPS
        
        Args:
            codigo_pagamento: Ex: "1007"
            competencia: Ex: "11/2025"
            valor: Ex: 303.60
            nit: Ex: "12800186722"
        
        Returns:
            dict com codigo_barras e linha_digitavel
        """
        
        # 1. Valor em centavos (11 d√≠gitos)
        valor_centavos = int(round(valor * 100))
        valor_str = str(valor_centavos).zfill(11)
        
        # 2. Identificador de valor (posi√ß√£o 3)
        if valor_centavos < 1000:
            id_valor = "6"
        elif valor_centavos < 10000:
            id_valor = "7"
        elif valor_centavos < 100000:
            id_valor = "8"
        else:
            id_valor = "9"
        
        # 3. Limpa NIT (s√≥ n√∫meros)
        nit_limpo = ''.join(filter(str.isdigit, nit))

        # üî¥ CORRE√á√ÉO CR√çTICA: Remove PRIMEIRO d√≠gito do NIT (n√£o o √∫ltimo!)
        # Exemplo: NIT "12800186722" ‚Üí usar "2800186722" (10 d√≠gitos)
        # O primeiro d√≠gito "1" vai para o campo_livre
        if len(nit_limpo) >= 11:
            primeiro_digito_nit = nit_limpo[0]      # Primeiro: "1"
            nit_10_digitos = nit_limpo[1:11]        # Remove primeiro: "2800186722"
        else:
            primeiro_digito_nit = "0"
            nit_10_digitos = nit_limpo[:10].zfill(10)

        # 4. Formata compet√™ncia especial (AAAAMM3)
        mes, ano = competencia.split('/')
        competencia_especial = ano + mes.zfill(2) + "3"  # "2025" + "11" + "3" = "2025113"

        # 5. Campo livre (4 d√≠gitos) = primeiro d√≠gito NIT + "000"
        campo_livre = primeiro_digito_nit + "000"  # "1000"

        # 6. MONTA C√ìDIGO SEM DV (47 d√≠gitos)
        # Estrutura GPS: 48 d√≠gitos totais (47 + 1 DV)
        codigo_sem_dv = (
            "8" +                           # Pos 1: Produto (8 = arrecada√ß√£o)
            "5" +                           # Pos 2: Segmento (5 = GPS)
            id_valor +                      # Pos 3: ID Valor (6/7/8/9)
            valor_str +                     # Pos 5-15: Valor (11 d√≠gitos) - ap√≥s inserir DV
            "0270" +                        # Pos 16-19: Campo GPS fixo
            codigo_pagamento.zfill(4) +     # Pos 20-23: C√≥digo pagamento
            "0001" +                        # Pos 24-27: Campo GPS fixo
            nit_10_digitos +                # Pos 28-37: NIT sem 1¬∫ d√≠gito (10 d√≠gitos)
            competencia_especial +          # Pos 38-44: Compet√™ncia AAAAMM3 (7 d√≠gitos)
            campo_livre                     # Pos 45-48: 1¬∫ d√≠gito NIT + 000 (4 d√≠gitos)
        )

        # Valida
        if len(codigo_sem_dv) != 47:
            raise ValueError(f"C√≥digo sem DV deve ter 47 d√≠gitos, tem {len(codigo_sem_dv)}")

        # 7. Calcula DV Geral (ser√° inserido na posi√ß√£o 4)
        dv = cls.calcular_dv_modulo11(codigo_sem_dv)

        # 8. Insere DV na posi√ß√£o 4 (ap√≥s "85" + id_valor)
        codigo_completo = codigo_sem_dv[:3] + dv + codigo_sem_dv[3:]

        # Valida comprimento final
        if len(codigo_completo) != 48:
            raise ValueError(f"C√≥digo final deve ter 48 d√≠gitos, tem {len(codigo_completo)}")
        
        # 9. Gera linha digit√°vel
        linha_digitavel = cls.gerar_linha_digitavel(codigo_completo)
        
        return {
            'codigo_barras': codigo_completo,
            'linha_digitavel': linha_digitavel,
            'valor': valor,
            'competencia': competencia
        }
    
    @classmethod
    def gerar_linha_digitavel(cls, codigo_barras: str) -> str:
        """
        Gera linha digit√°vel GPS

        üî¥ CORRE√á√ÉO: C√≥digo tem 48 d√≠gitos, mas linha digit√°vel usa apenas os primeiros 44
        √öltimos 4 d√≠gitos (campo_livre) N√ÉO aparecem na linha digit√°vel
        """
        if len(codigo_barras) != 48:
            raise ValueError(f"C√≥digo deve ter 48 d√≠gitos, tem {len(codigo_barras)}")

        # 1. Pega apenas os primeiros 44 d√≠gitos
        codigo_44 = codigo_barras[:44]

        campos = []

        # 2. Divide em 4 campos de 11 d√≠gitos cada
        for i in range(0, 44, 11):
            campo_11_digitos = codigo_44[i:i+11]

            # 3. Calcula DV do campo (M√≥dulo 10, direita para esquerda)
            campo_dv = cls.calcular_dv_modulo10(campo_11_digitos)

            # 4. Formata: XXXXXXXXXXX-D
            campos.append(f"{campo_11_digitos}-{campo_dv}")

        # 5. Junta com espa√ßos
        return " ".join(campos)

    @staticmethod
    def validar(codigo_barras: str) -> bool:
        """
        Valida um c√≥digo de barras GPS verificando:
        - Comprimento (48 d√≠gitos)
        - D√≠gito verificador (posi√ß√£o 4)

        Args:
            codigo_barras: C√≥digo de barras de 48 d√≠gitos

        Returns:
            True se v√°lido, False caso contr√°rio
        """
        # Verifica comprimento
        if not codigo_barras or len(codigo_barras) != 48:
            return False

        # Verifica se s√£o todos d√≠gitos
        if not codigo_barras.isdigit():
            return False

        # Extrai o DV da posi√ß√£o 4
        dv_informado = codigo_barras[3]

        # Reconstr√≥i c√≥digo sem DV (remove posi√ß√£o 4)
        codigo_sem_dv = codigo_barras[:3] + codigo_barras[4:]

        # Calcula DV esperado
        dv_calculado = CodigoBarrasGPS.calcular_dv_modulo11(codigo_sem_dv)

        # Compara
        return dv_informado == dv_calculado


# ==============================================================================
# TESTE FINAL
# ==============================================================================

if __name__ == "__main__":
    print("üß™ TESTE FINAL DO C√ìDIGO CORRIGIDO\n")
    print("=" * 80)
    
    # Dados reais que geram o c√≥digo do SAL
    resultado = CodigoBarrasGPS.gerar(
        codigo_pagamento="1007",
        competencia="11/2025",
        valor=303.60,
        nit="12800186722"
    )
    
    print("[STATS] RESULTADO GERADO:")
    print(f"C√≥digo:  {resultado['codigo_barras']}")
    print(f"Linha:   {resultado['linha_digitavel']}")
    
    print("\n[STATS] C√ìDIGO REAL DO SAL (Que funciona no banco):")
    linha_esperada = "85810000003-0 03600270100-7 70001280018-4 67222025113-0"
    print(f"Linha:   {linha_esperada}")
    
    print("\n[STATS] COMPARA√á√ÉO:")
    match = resultado['linha_digitavel'] == linha_esperada
    print(f"Match: {'[OK] PERFEITO!' if match else '[ERROR] Diferente'}")
    
    if match:
        print("\nüéâ SUCESSO! O c√≥digo est√° 100% correto!")
        print("   Pode usar no banco sem problemas!")
    else:
        print("\n[WARN]  Ainda h√° diferen√ßa:")
        print(f"   Gerado:   {resultado['linha_digitavel']}")
        print(f"   Esperado: {linha_esperada}")
    
    print("\n" + "=" * 80)
